<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>ARW Analysis Report</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="report.css" rel="stylesheet">
</head>
<body>
  <div class="container-fluid py-4 content-wrap">
    <h1 class="mb-1">ARW Analysis Report</h1>
    <p class="mb-3">Toggle decisions per photo and export as JSON.</p>
    <div id="summary" class="summary"></div>
    <div class="mb-3">
      <button id="export" class="btn btn-primary btn-sm">Download decisions JSON</button>
    </div>
    <div id="loading" class="d-flex align-items-center justify-content-center py-3">
      <div class="spinner-border text-primary me-2" role="status" aria-hidden="true"></div>
      <span class="text-muted">Loading...</span>
    </div>
    <div class="lightbox" id="lightbox">
      <button id="lightbox-close" class="btn btn-light lightbox-close" aria-label="Close viewer">✕</button>
      <button id="lightbox-prev" class="btn btn-light" aria-label="Previous image">❮</button>
      <img id="lightbox-img" src="" alt="Preview" />
      <button id="lightbox-next" class="btn btn-light" aria-label="Next image">❯</button>
    </div>
    <div class="table-responsive mt-3">
      <table class="table table-hover align-middle table-alt">
        <thead>
          <tr id="header-row"></tr>
        </thead>
        <tbody id="rows"></tbody>
      </table>
    </div>
  </div>
  <script id="data" type="application/json">__DATA_JSON__</script>
  <script>
    const payload = JSON.parse(document.getElementById("data").textContent);
    const data = payload.results || [];
    const cfgAnalysis = (payload.config && payload.config.analysis) || {};
    const tbody = document.getElementById("rows");
    const lightbox = document.getElementById("lightbox");
    const lightboxImg = document.getElementById("lightbox-img");
    const btnPrev = document.getElementById("lightbox-prev");
    const btnNext = document.getElementById("lightbox-next");
    const btnClose = document.getElementById("lightbox-close");
    const loading = document.getElementById("loading");
    let currentOrder = [];
    let orderLookup = new Map();
    let currentLightboxPos = null;

    function openLightbox(pos) {
      if (!currentOrder.length) return;
      if (pos < 0 || pos >= currentOrder.length) return;
      const idx = currentOrder[pos];
      const item = data[idx];
      if (!item) return;
      currentLightboxPos = pos;
      lightboxImg.src = item.preview.replace(/\\/g, "/");
      lightbox.classList.add("open");
    }
    function closeLightbox() {
      lightbox.classList.remove("open");
      currentLightboxPos = null;
    }
    function stepLightbox(delta) {
      if (currentLightboxPos === null) return;
      const nextPos = (currentLightboxPos + delta + currentOrder.length) % currentOrder.length;
      openLightbox(nextPos);
    }
    lightbox.onclick = (e) => {
      if (e.target === lightbox) closeLightbox();
    };
    btnPrev.onclick = (e) => { e.stopPropagation(); stepLightbox(-1); };
    btnNext.onclick = (e) => { e.stopPropagation(); stepLightbox(1); };
    btnClose.onclick = (e) => { e.stopPropagation(); closeLightbox(); };

    const groups = {};
    data.forEach((item, idx) => {
      if (item.duplicate_group !== undefined) {
        const g = item.duplicate_group;
        if (!groups[g]) groups[g] = [];
        groups[g].push(idx);
      }
    });

    const thresholds = {
      sharpnessMin: 8,
      tenengradMin: 200,
      motionRatioMin: 0.02,
      noiseStdMax: 25,
      brightnessMin: 0.08,
      brightnessMax: 0.92,
      highlightsMax: 0.92,
      shadowsMax: 0.5,
    };

    const clamp01 = (v) => Math.min(1, Math.max(0, v));
    const scoreColor = (score) => {
      const hue = Math.round(score * 120); // 0 = red, 120 = green
      const light = Math.round(35 + 20 * score); // darker red when low, lighter green when high
      return `hsl(${hue}, 75%, ${light}%)`;
    };

    function scoreColorFromRatio(ratio) {
      const r = Math.max(0, ratio);
      let hue;
      let light;
      if (r < 1) {
        hue = 0;
        light = 18 + 28 * r; // dark red to brighter red
      } else {
        const scaled = Math.min(1, (r - 1)); // cap at 2x threshold
        hue = scaled * 120;
        light = 46 + 14 * scaled;
      }
      return `hsl(${Math.round(hue)}, 75%, ${Math.round(light)}%)`;
    }

    function metricRatio(metric, value) {
      const thresholds = {
        sharpnessMin: cfgAnalysis.sharpness_min ?? 8,
        tenengradMin: cfgAnalysis.tenengrad_min ?? 200,
        motionRatioMin: cfgAnalysis.motion_ratio_min ?? 0.02,
        noiseStdMax: cfgAnalysis.noise_std_max ?? 25,
        brightnessMin: cfgAnalysis.brightness_min ?? 0.08,
        brightnessMax: cfgAnalysis.brightness_max ?? 0.92,
        qualityScoreMin: cfgAnalysis.quality_score_min ?? 0.75,
        shadowsMin: cfgAnalysis.shadows_min ?? 0.0,
        shadowsMax: cfgAnalysis.shadows_max ?? 0.5,
        highlightsMin: cfgAnalysis.highlights_min ?? 0.0,
        highlightsMax: cfgAnalysis.highlights_max ?? 0.1,
      };

      switch (metric) {
        case "sharpness":
          return (value || 0) / Math.max(thresholds.sharpnessMin || 1, 1e-6);
        case "tenengrad":
          return (value || 0) / Math.max(thresholds.tenengradMin || 1, 1e-6);
        case "motion_ratio":
          return (value || 0) / Math.max(thresholds.motionRatioMin || 1, 1e-6);
        case "noise":
          return Math.max(thresholds.noiseStdMax || 1, 1e-6) / Math.max(value || 0, 1e-6);
        case "brightness": {
          if (value === undefined || value === null || Number.isNaN(value)) return 0;
          const mid = (thresholds.brightnessMin + thresholds.brightnessMax) / 2;
          const half = (thresholds.brightnessMax - thresholds.brightnessMin) / 2;
          return clamp01(1 - Math.abs(value - mid) / Math.max(half, 1e-6));
        }
        case "quality_score": {
          const min = thresholds.qualityScoreMin || 0.75;
          return (value || 0) / Math.max(min, 1e-6);
        }
        case "shadows": {
          const val = value || 0;
          if (val < thresholds.shadowsMin) {
            return clamp01(1 - (thresholds.shadowsMin - val) / Math.max(thresholds.shadowsMin, 1e-6));
          }
          if (val > thresholds.shadowsMax) {
            return clamp01(1 - (val - thresholds.shadowsMax) / Math.max(1 - thresholds.shadowsMax, 1e-6));
          }
          return 1;
        }
        case "highlights": {
          const val = value || 0;
          if (val < thresholds.highlightsMin) {
            return clamp01(1 - (thresholds.highlightsMin - val) / Math.max(thresholds.highlightsMin, 1e-6));
          }
          if (val > thresholds.highlightsMax) {
            return clamp01(1 - (val - thresholds.highlightsMax) / Math.max(1 - thresholds.highlightsMax, 1e-6));
          }
          return 1;
        }
        default:
          return null;
      }
    }
    function formatCapture(item) {
      const iso = item.capture_time;
      if (iso) {
        const d = new Date(iso);
        if (!Number.isNaN(d.getTime())) {
          const y = d.getFullYear();
          const m = String(d.getMonth() + 1).padStart(2, "0");
          const day = String(d.getDate()).padStart(2, "0");
          const hh = String(d.getHours()).padStart(2, "0");
          const mm = String(d.getMinutes()).padStart(2, "0");
          return `${y}-${m}-${day} ${hh}:${mm}`;
        }
        if (iso.length >= 16) return iso.replace("T", " ").slice(0, 16);
        return iso;
      }
      return "n/a";
    }
    function badgeStyle(metric, value) {
      const ratio = metricRatio(metric, value);
      if (ratio === null) return null;
      const backgroundColor = scoreColorFromRatio(ratio);
      const color = ratio > 0.65 ? "#0b1223" : "#f8fafc";
      return { backgroundColor, color };
    }

    function createBadge(text, metric, value) {
      const div = document.createElement("div");
      div.className = "metric-badge me-1";
      const hasValue = value !== undefined && value !== null && !Number.isNaN(value);
      if (metric !== null && metric !== undefined && hasValue) {
        const style = badgeStyle(metric, value);
        if (style) {
          Object.assign(div.style, style);
        }
      }
      div.textContent = text;
      return div;
    }

    const columns = [
      {
        key: "path",
        label: "File",
        sortable: true,
        type: "string",
        getter: (item) => item.path?.toLowerCase() ?? "",
      },
      {
        key: "capture",
        label: "Captured",
        sortable: true,
        type: "number",
        getter: (item) => item.capture_ts ?? 0,
        format: (_v, item) => formatCapture(item),
      },
      { key: "preview", label: "Preview", sortable: false },
      { key: "sharpness_center", label: "Center sharpness", sortable: true, type: "number", metric: "sharpness", format: (v) => v.toFixed(1) },
      { key: "decision", label: "Decision", sortable: true, type: "string", getter: (item) => item.decision ?? "" },
      { key: "reasons", label: "Reasons", sortable: false },
      { key: "quality_score", label: "Quality score", sortable: true, type: "number", metric: "quality_score", format: (v) => v.toFixed(2) },
      { key: "sharpness", label: "Sharpness", sortable: true, type: "number", metric: "sharpness", format: (v) => v.toFixed(1) },
      { key: "tenengrad", label: "Tenengrad", sortable: true, type: "number", metric: "tenengrad", format: (v) => v.toFixed(0) },
      { key: "motion_ratio", label: "Motion ratio", sortable: true, type: "number", metric: "motion_ratio", format: (v) => `${(v * 100).toFixed(0)}%` },
      { key: "noise", label: "Noise std", sortable: true, type: "number", metric: "noise", format: (v) => v.toFixed(1) },
      {
        key: "brightness",
        label: "Brightness",
        sortable: true,
        type: "number",
        metric: "brightness",
        getter: (item) => item.brightness?.mean,
        format: (v) => `${(v * 100).toFixed(0)}%`,
      },
      {
        key: "shadows",
        label: "Shadows",
        sortable: true,
        type: "number",
        metric: "shadows",
        getter: (item) => item.brightness?.shadows,
        format: (v) => `${(v * 100).toFixed(0)}%`,
      },
      {
        key: "highlights",
        label: "Highlights",
        sortable: true,
        type: "number",
        metric: "highlights",
        getter: (item) => item.brightness?.highlights,
        format: (v) => `${(v * 100).toFixed(0)}%`,
      },
      { key: "composition", label: "Composition", sortable: true, type: "number", format: (v) => v.toFixed(2) },
      { key: "faces", label: "Faces", sortable: true, type: "number", getter: (item) => item.faces?.count ?? 0 },
      { key: "face_sharpness", label: "Face sharpness", sortable: true, type: "number", getter: (item) => item.faces?.best_sharpness, format: (v) => v.toFixed(1) },
    ];
    const columnsByKey = Object.fromEntries(columns.map((c) => [c.key, c]));
    const headerRow = document.getElementById("header-row");
    let sortState = { key: "path", dir: "asc" };

    function buildHeader() {
      headerRow.innerHTML = "";
      columns.forEach((col) => {
        const th = document.createElement("th");
        th.textContent = col.label;
        if (col.sortable !== false) {
          th.classList.add("sortable");
          const indicator = document.createElement("span");
          indicator.className = "sort-indicator";
          indicator.textContent =
            sortState.key === col.key ? (sortState.dir === "asc" ? "⇅" : "⇅") : "⇅";
          th.appendChild(indicator);
          th.onclick = () => toggleSort(col.key);
        }
        headerRow.appendChild(th);
      });
    }

    function toggleSort(key) {
      const col = columnsByKey[key];
      if (!col || col.sortable === false) return;
      if (sortState.key === key) {
        sortState.dir = sortState.dir === "asc" ? "desc" : "asc";
      } else {
        sortState = { key, dir: "asc" };
      }
      render();
    }

    function valueForSort(item, col) {
      if (!col) return item.path ?? "";
      if (col.getter) return col.getter(item);
      return item[col.key];
    }

    function compareValues(a, b, col) {
      const direction = sortState.dir === "asc" ? 1 : -1;
      if (a === undefined || a === null) return (b === undefined || b === null) ? 0 : 1;
      if (b === undefined || b === null) return -1;
      if (col && col.type === "string") {
        return a.toString().localeCompare(b.toString()) * direction;
      }
      if (a > b) return 1 * direction;
      if (a < b) return -1 * direction;
      return 0;
    }

    function hasOtherKeep(groupId, excludeIdx) {
      if (!groups[groupId]) return false;
      return groups[groupId].some(i => i !== excludeIdx && data[i].decision === "keep");
    }

    function render() {
      buildHeader();
      const fragment = document.createDocumentFragment();
      const stats = { total: data.length, keep: 0, discard: 0 };
      const colForSort = columnsByKey[sortState.key];
      const sortedIdx = data.map((_, idx) => idx).sort((a, b) => {
        const av = valueForSort(data[a], colForSort);
        const bv = valueForSort(data[b], colForSort);
        const cmp = compareValues(av, bv, colForSort);
        if (cmp !== 0) return cmp;
        return (data[a].path ?? "").localeCompare(data[b].path ?? "");
      });
      currentOrder = sortedIdx;
      orderLookup = new Map(sortedIdx.map((id, pos) => [id, pos]));
      currentLightboxPos = null;

      sortedIdx.forEach((idx) => {
        const item = data[idx];
        const tr = document.createElement("tr");

        columns.forEach((col) => {
          const td = document.createElement("td");
          switch (col.key) {
            case "preview": {
              const img = document.createElement("img");
              img.className = "preview";
              img.src = item.preview.replace(/\\/g, "/");
              img.loading = "lazy";
              img.onclick = () => {
                const pos = orderLookup.get(idx) ?? 0;
                openLightbox(pos);
              };
              td.appendChild(img);
              break;
            }
            case "path": {
              const filename = (item.path || "").split(/[/\\]/).pop();
              td.textContent = filename;
              if (item.duplicate_of) {
                const badge = document.createElement("div");
                badge.className = "badge bg-light text-dark border";
                const dupName = item.duplicate_of.split(/[/\\]/).pop();
                badge.textContent = "Duplicate of: " + dupName;
                td.appendChild(badge);
              }
              break;
            }
            case "capture": {
              td.textContent = formatCapture(item);
              break;
            }
            case "decision": {
              const decisionClass = item.decision === "keep" ? "decision-keep" : "decision-discard";
              td.className = `decision-cell ${decisionClass}`;
              const controls = document.createElement("div");
              controls.className = "controls d-flex gap-2";
              const btnKeep = document.createElement("button");
              btnKeep.textContent = "Keep";
              btnKeep.className = "btn btn-success btn-sm";
              btnKeep.onclick = () => { item.decision = "keep"; render(); };
              const btnDrop = document.createElement("button");
              btnDrop.textContent = "Discard";
              btnDrop.className = "btn btn-danger btn-sm";
              btnDrop.onclick = () => {
                if (item.duplicate_group !== undefined && !hasOtherKeep(item.duplicate_group, idx)) {
                  alert("At least one photo in a duplicate set must be kept.");
                  return;
                }
                item.decision = "discard";
                render();
              };
              controls.appendChild(btnKeep);
              controls.appendChild(btnDrop);
              td.appendChild(controls);
              break;
            }
            case "reasons": {
              if (item.reasons && item.reasons.length) {
                td.textContent = item.reasons.join(", ");
              } else {
                td.textContent = "-";
              }
              break;
            }
            default: {
              const value = col.getter ? col.getter(item) : item[col.key];
              const hasValue = value !== undefined && value !== null && !Number.isNaN(value);
              const display = hasValue
                ? (col.format ? col.format(value, item) : value)
                : "n/a";
              if (col.metric) {
                td.appendChild(createBadge(display, col.metric, value));
              } else {
                td.textContent = display;
              }
            }
          }
          tr.appendChild(td);
        });
        fragment.appendChild(tr);

        if (item.decision === "keep") stats.keep += 1; else stats.discard += 1;
      });
      tbody.replaceChildren(fragment);

      const keepPct = stats.total ? Math.round((stats.keep / stats.total) * 100) : 0;
      const discardPct = stats.total ? Math.round((stats.discard / stats.total) * 100) : 0;
      const summaryDiv = document.getElementById("summary");
      summaryDiv.textContent = `Keeps: ${keepPct}% (${stats.keep}/${stats.total}) • Discards: ${discardPct}% (${stats.discard}/${stats.total})`;

      if (loading && loading.parentNode) {
        loading.parentNode.removeChild(loading);
      }
    }

    render();

    document.getElementById("export").onclick = () => {
      const blob = new Blob([JSON.stringify(data, null, 2)], {type: "application/json"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "decisions.json";
      a.click();
      URL.revokeObjectURL(url);
    };
  </script>
</body>
</html>
